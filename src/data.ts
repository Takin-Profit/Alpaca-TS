/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/v2/stocks/bars": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Bar data for multiple stock symbols
		 * @description The Multi Bars API returns aggregate historical data for multiple given ticker symbols over a specified time period.
		 *
		 *     Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
		 */
		get: operations["getBarsForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/bars/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest Bar data for multiple stock symbols
		 * @description The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbols.
		 */
		get: operations["getLatestBarsForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/bars": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Bars
		 * @description The Bars API returns aggregate historical data for the requested security. Returns bars for the queried stock symbol.
		 */
		get: operations["getBarsForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/bars/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Latest Bars for Symbol
		 * @description The Bars API returns aggregate historical data for the requested security. Returns the latest bar data for the queried stock symbol.
		 */
		get: operations["getLatestBarForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/trades": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Trade data for multiple stock symbols
		 * @description The Multi Trades API provides historical trade data for multiple given ticker symbols over a specified time period.
		 *
		 *     Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
		 */
		get: operations["getTradesForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/trades/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest Trades data for multiple stock symbols
		 * @description Returns the latest trades data for the queried stock symbols.
		 */
		get: operations["getLatestTradesForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/trades": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Trades
		 * @description The Trades API provides historical trade data for a given ticker symbol on a specified date. Returns trades for the queried stock signal.
		 */
		get: operations["getTradesForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/trades/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Latest Trade
		 * @description The Latest Trade API provides the latest trade data for a given ticker symbol.
		 */
		get: operations["getLatestTradeForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/quotes": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Quotes for multiple stock symbols
		 * @description The Multi Quotes API provides NBBO quotes for multiple given ticker symbols over a specified time period.
		 *
		 *     Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
		 */
		get: operations["getQuotesForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/quotes/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest Quotes for multiple stock symbols
		 * @description Returns the latest quotes data for the queried stock symbols.
		 */
		get: operations["getLatestQuotesForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/quotes": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Quotes for stock symbol
		 * @description The Quotes API provides NBBO quotes for a single given ticker symbol at a specified date. Returns quotes (NBBOs) for the querried stock symbol.
		 */
		get: operations["getQuotesForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/quotes/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Latest Quote for stock symbol
		 * @description The Latest Quote API provides the latest quote data for a given ticker symbol.
		 */
		get: operations["getLatestQuoteForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/snapshots": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Snapshots for multiple stock symbols
		 * @description The Snapshot API for multiple tickers provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for the given ticker symbols.
		 */
		get: operations["getSnapshotsForMultipleStockSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/{symbol}/snapshot": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get a Snapshot for a stock symbol
		 * @description The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol. This endpoint returns the snapshot for the requested security.
		 */
		get: operations["getSnapshotForStockSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/trades": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Trade data for multiple crypto symbols
		 * @description The Multi Trades API provides historical trade data for a list of given crypto symbols on a specified date. Returns trades for the queried crypto symbols.
		 *
		 *     Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
		 */
		get: operations["getTradesForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/trades/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest Trade data for multiple Crypto symbols
		 * @description Provides latest trade data for a list of given crypto symbols.
		 */
		get: operations["getLatestTradesForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/trades": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Trade data for a crypto symbol
		 * @description The Trades API provides historical trade data for a given crypto symbol on a specified date. Returns trades for the queried crypto symbol
		 */
		get: operations["getTradesForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/trades/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Latest Trades
		 * @description The Latest Trades API provides the latest historical trade data for a given crypto symbol. Returns trades for the queried crypto symbol.
		 */
		get: operations["getLatestTradesForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/bars": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Bars for multiple Crypto symbols
		 * @description returns aggregate historical data for the requested crypto symbols.
		 *
		 *     Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them.
		 */
		get: operations["getBarsForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/bars/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest Bars for multiple Crypto symbols
		 * @description returns latest historical data for the requested crypto symbols for a specific exchange
		 */
		get: operations["getLatestBarsForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/bars": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Bar data for a crypto symbol
		 * @description The Bars API returns aggregate historical data for the requested securities.. Returns bars for the queried crypto symbol
		 */
		get: operations["getBarsForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/bars/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Latest Bar data for a Crypto symbol
		 * @description Gets latest historical bar data for the requested crypto symbol for a specific exchange
		 */
		get: operations["getLatestBarsForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/quotes": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Quotes for multiple crypto symbols
		 * @description The Multi Quotes API provides quotes for a list of given crypto symbols at a specified date. Returns quotes for each of  the queried crypto symbols.
		 *
		 *     Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
		 */
		get: operations["getQuotesForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/quotes/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest Quotes for multiple Crypto symbols
		 * @description Provides latest quotes for a list of given crypto symbols.
		 */
		get: operations["getLatestQuotesForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/quotes": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Quotes for crypto symbol
		 * @description The Quotes API provides quotes for a given crypto symbol at a specified date. Returns quotes for the queried crypto symbol
		 */
		get: operations["getQuotesForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/quotes/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Latest Quote
		 * @description Returns latest quote for the queried crypto symbol
		 */
		get: operations["getLatestQuoteForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/snapshots": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Snapshots for multiple crypto symbols
		 * @description The Multi Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for list of given crypto symbols.
		 */
		get: operations["getSnapshotsForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/snapshot": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get a Snapshot for a crypto symbol
		 * @description The Snapshot API returns the latest trade, latest quote, minute bar daily bar, and previous daily bar data for a given crypto symbol.
		 */
		get: operations["getSnapshotForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/xbbos/latest": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get Latest XBBO for multiple crypto symbols
		 * @description Returns the latest XBBO for a given list crypto symbols that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
		 */
		get: operations["getLatestXBBOForMultipleCryptoSymbols"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/{symbol}/xbbo/latest": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		/**
		 * Get Latest XBBO for a single crypto symbol
		 * @description Returns the XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges. If exchanges is not specified then only the exchanges that can be traded on Alpaca are included in the calculation.
		 */
		get: operations["getLatestXBBOForCryptoSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/crypto/meta/spreads": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get list of crypto spreads per exchange
		 * @description Get list of crypto spreads for the different exchanges Alpaca supports in basis points.
		 */
		get: operations["getCryptoMetaSpreads"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/news": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * News API
		 * @description Returns latest news articles across stocks and crypto. By default returns latest 10 news articles.
		 */
		get: operations["getNews"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/screener/{market_type}/movers": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description Screen specific market (stocks or crypto) */
				market_type: "stocks" | "crypto"
			}
			cookie?: never
		}
		/**
		 * Get Top Market Movers by Market type
		 * @description Returns top market movers for stocks. By default will return top 5 market gainers and losers.
		 */
		get: operations["getTopMoversByMarketType"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v1beta1/logos/{crypto_or_stock_symbol}": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description The crypto or stock symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				crypto_or_stock_symbol: string
			}
			cookie?: never
		}
		/**
		 * Get Logo for symbol
		 * @description Returns logo image resource for provided symbol.
		 */
		get: operations["getLogoForSymbol"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/meta/exchanges": {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		/**
		 * Get List of supported exchanges
		 * @description Returns a json object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
		 */
		get: operations["getExchanges"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
	"/v2/stocks/meta/conditions/{type}": {
		parameters: {
			query?: never
			header?: never
			path: {
				/** @description either "trade" or "quote" */
				type: "trade" | "quote"
			}
			cookie?: never
		}
		/**
		 * Get list of Conditions
		 * @description Each feed/exchange uses its own set of codes to identify trade and quote conditions, so the same condition may have a different code depending on the originator of the data.
		 *
		 *     See [Our documentation](https://alpaca.markets/docs/market-data/#conditions) for more information
		 */
		get: operations["getConditions"]
		put?: never
		post?: never
		delete?: never
		options?: never
		head?: never
		patch?: never
		trace?: never
	}
}
export type webhooks = Record<string, never>
export interface components {
	schemas: {
		/**
		 * Trade
		 * @description A model representing a trade
		 */
		Trade: {
			/**
			 * Format: date-time
			 * @description Timestamp in RFC-3339 format with nanosecond precision
			 */
			t?: string
			/** @description Exchange where the trade happened. */
			x: string
			/** @description Trade price. */
			p?: number
			/** @description Trade Size. */
			s?: number
			/** @description Trade conditions (Stock trade only) */
			c?: string[]
			/**
			 * Format: int64
			 * @description Trade ID
			 */
			i: number
			/** @description Tape (Stock trade only) */
			z?: string
			/** @description Taker's side (crypto trade only) */
			tks?: string
		}
		/**
		 * TradesResponse
		 * @description A model representing the result of hitting the Trades api.
		 *
		 *     Represents multiple Trades for a single symbol with support for paging.
		 */
		TradesResponse: {
			/** @description Array of trades */
			trades: components["schemas"]["Trade"][]
			/**
			 * @description Symbol that was queried
			 * @example AAPL
			 */
			symbol: string
			/** @description Token that can be used to query the next page */
			next_page_token?: string | null
		}
		/**
		 * LatestTradeResponse
		 * @description A model representing the result of hitting the Latest Trade api.
		 *
		 *     Represents a single Trade that should be the latest trade data for a given ticker symbol
		 */
		LatestTradeResponse: {
			trade?: components["schemas"]["Trade"]
			/**
			 * @description Symbol that was queried
			 * @example AAPL
			 */
			symbol: string
		}
		/**
		 * MultiTradesResponse
		 * @description A model representing the result of hitting the Multi Trades api; represents multiple trades for multiple symbols.
		 *
		 *     Returned results are sorted by symbol first then by Trade timestamp. This means that you are likely to see only one symbol in your first response if there are enough Trades for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Trades were found for them.
		 *
		 */
		MultiTradesResponse: {
			trades: {
				[key: string]: components["schemas"]["Trade"][]
			}
			next_page_token?: string | null
		}
		LatestMultiTradesResponse: {
			trades: {
				[key: string]: components["schemas"]["Trade"]
			}
		}
		/**
		 * Snapshot
		 * @description The Snapshot API for one ticker provides the latest trade, latest quote, minute bar daily bar and previous daily bar data for a given ticker symbol.
		 *
		 */
		Snapshot: {
			latestTrade?: components["schemas"]["Trade"]
			latestQuote?: components["schemas"]["Quote"]
			minuteBar?: components["schemas"]["Bar"]
			dailyBar?: components["schemas"]["Bar"]
			prevDailyBar?: components["schemas"]["Bar"]
		}
		/**
		 * MultiSnapshotResponse
		 * @description A model representing the result of hitting the Multi Snapshots api; represents Snapshots for multiple symbols.
		 *
		 *     The result is an object whose keys are the requested symbols and values are their respecitve Snapshot
		 *
		 */
		MultiSnapshotResponse: {
			[key: string]: components["schemas"]["Snapshot"]
		}
		/**
		 * Quote
		 * @description The Quotes API provides NBBO quotes for a given ticker symbol at a specified date.
		 *
		 */
		Quote: {
			/**
			 * Format: date-time
			 * @description Timestamp in RFC-3339 format with nanosecond precision
			 */
			t: string
			/** @description ask exchange (Stock quote only) */
			ax?: string
			/** @description ask price
			 *      */
			ap?: number
			/** @description ask size
			 *      */
			as?: number
			/** @description bid exchange (Stock quote only) */
			bx?: string
			/** @description bid price
			 *      */
			bp?: number
			/** @description bid size */
			bs?: number
			/** @description quote conditions (Stock quotes only) */
			c?: string[]
			/** @description Exchange (Crypto quote Only) */
			x?: string
			/** @description Tape (Stock quote only) */
			z?: string
		}
		/**
		 * QuotesResponse
		 * @description The Quotes API provides NBBO quotes for a given ticker symbol at a specified date.
		 *
		 */
		QuotesResponse: {
			quotes: components["schemas"]["Quote"][] | null
			/** @example AAPL */
			symbol: string
			next_page_token?: string | null
		}
		/**
		 * LatestQuotesResponse
		 * @description A model representing the result of hitting the Latest Quote api.
		 *
		 *     Represents a single Quote that should be the latest quote data for a given ticker symbol
		 */
		LatestQuoteResponse: {
			quote: components["schemas"]["Quote"]
			/** @example AAPL */
			symbol: string
		}
		/**
		 * MultiQuotesReponse
		 * @description A model representing the result of hitting the Multi Quotes api; represents multiple Quotes for multiple symbols.
		 *
		 *     Returned results are sorted by symbol first then by Quote timestamp. This means that you are likely to see only one symbol in your first response if there are enough Quotes for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Quotes were found for them.
		 *
		 */
		MultiQuotesReponse: {
			quotes: {
				[key: string]: components["schemas"]["Quote"][]
			}
			/** @description pass this token with your request again to get the next page of results */
			next_page_token?: string | null
		}
		LatestMultiQuotesResponse: {
			quotes: {
				[key: string]: components["schemas"]["Quote"]
			}
		}
		/**
		 * Bar
		 * @description The bars API returns aggregate historical data for the requested securities.
		 *
		 */
		Bar: {
			/**
			 * Format: date-time
			 * @description Timestamp in RFC-3339 format with nanosecond precision.
			 */
			t: string
			/**
			 * @description Exchange. Only present on Bars for Crypto symbols
			 * @enum {string}
			 */
			x?: "FTXU" | "ERSX" | "CBSE"
			/** @description Open price */
			o: number
			/** @description High price. */
			h: number
			/** @description Low price.
			 *      */
			l: number
			/** @description Close price. */
			c: number
			/** @description Volume. */
			v: number
			/**
			 * Format: int64
			 * @description Number of trades.
			 */
			n?: number
			/** @description Volume weighted average price. */
			vw?: number
		}
		/** BarsResponse */
		BarsResponse: {
			/** @description The array of Bar data */
			bars: components["schemas"]["Bar"][]
			/**
			 * @description the stock ticker or crypto symbol this set of bar data is for
			 * @example AAPL
			 */
			symbol: string
			next_page_token: string | null
		}
		/** @description A model representing the result of hitting one of the Latest Bar api endpoints.
		 *
		 *     Represents a single Bar that should be the latest Bar data for a given ticker symbol */
		LatestBarResponse: {
			symbol: string
			bar: components["schemas"]["Bar"]
		}
		/**
		 * MultiBarsResponse
		 * @description A model representing the result of hitting the Multi Bars api; represents multiple Bars for multiple symbols.
		 *
		 *     Returned results are sorted by symbol first then by Bar timestamp. This means that you are likely to see only one symbol in your first response if there are enough Bars in the duration you specified for that symbol to hit the limit you requested on that request.
		 *
		 *     In these situations if you keep requesting again with the next_page_token you will eventually reach the next symbols if any Bars were found for them in the timeframe.
		 *
		 */
		MultiBarsResponse: {
			bars: {
				[key: string]: components["schemas"]["Bar"][]
			}
			next_page_token?: string | null
		}
		/**
		 * LatestMultiBarsResponse
		 * @description A model representing the result of hitting the Latest Multi Bars api; represents the latest Bars for multiple symbols.
		 *
		 */
		LatestMultiBarsResponse: {
			bars: {
				[key: string]: components["schemas"]["Bar"]
			}
		}
		/** @description Model representing a news article from the Alpaca Market Data API */
		News: {
			/**
			 * Format: int64
			 * @description News article ID
			 */
			id: number
			/** @description Headline or title of the article */
			headline: string
			/** @description Original author of news article */
			author: string
			/**
			 * Format: date-time
			 * @description Date article was created (RFC 3339)
			 */
			created_at: string
			/**
			 * Format: date-time
			 * @description Date article was updated (RFC 3339)
			 */
			updated_at: string
			/** @description Summary text for the article (may be first sentence of content) */
			summary: string
			/** @description Content of the news article (might contain HTML) */
			content: string
			/**
			 * Format: uri
			 * @description URL of article (if applicable)
			 */
			url?: string | null
			/** @description List of images (URLs) related to given article (may be empty) */
			images: components["schemas"]["NewsImage"][]
			/** @description List of related or mentioned symbols */
			symbols: string[]
			/** @description Source where the news originated from (e.g. Benzinga) */
			source: string
		}
		/**
		 * NewsImage
		 * @description A model representing images for news article. simply a url to the image along with a size parameter suggesting the display size of the image
		 */
		NewsImage: {
			/**
			 * @description Possible values for size are thumb, small and large.
			 * @example thumb
			 * @enum {string}
			 */
			readonly size: "thumb" | "small" | "large"
			/**
			 * Format: uri
			 * @description url to image from news article
			 */
			readonly url: string
		}
		/** GetNewsResponse */
		GetNewsResponse: {
			news?: components["schemas"]["News"][]
			/** @description Pagination token for next page */
			next_page_token?: string
		}
		/**
		 * XBBO
		 * @description XBBO or Cross Best Bid and Offer represents the Best Bid and Offer for an exchange
		 */
		XBBO: {
			/**
			 * Format: date-time
			 * @description Timestamp in RFC-3339 format with nanosecond precision.
			 */
			t: string
			/** @description Ask exchange. */
			ax: string
			/** @description Ask price. */
			ap: number
			/** @description Ask size. */
			as: number
			/** @description Bid exchange. */
			bx: string
			/** @description Bid price. */
			bp: number
			/** @description Bid size. */
			bs: number
		}
		/**
		 * LatestXBBOResponse
		 * @description Represents the Latest XBBO for a crypto symbol that calculates the Best Bid and Offer across multiple exchanges.
		 */
		LatestXBBOResponse: {
			symbol: string
			xbbo: components["schemas"]["XBBO"]
		}
		LatestMultiXBBOResponse: {
			xbbos: {
				[key: string]: components["schemas"]["XBBO"]
			}
		}
		CryptoSpreadsResponse: {
			spreads: {
				[key: string]: number
			}
		}
		/**
		 * MarketMovers
		 * @description Contains list of market movers
		 */
		MarketMoversResponse: {
			/** @description List of top N gainers */
			gainers: components["schemas"]["MarketMoverAsset"][]
			/** @description List of top N losers */
			losers: components["schemas"]["MarketMoverAsset"][]
			/**
			 * @description Market type (stocks or crypto)
			 * @enum {string}
			 */
			market_type: "stocks" | "crypto"
			/** @description Time the movers where last computed */
			last_updated: string
		}
		/**
		 * MarketMoverAsset
		 * @description Name or source of given news article
		 */
		MarketMoverAsset: {
			/** @description Symbol of market moving asset */
			symbol: string
			/** @description Percentage difference change for the day */
			percent_change: number
			/** @description Difference in change for the day */
			change: number
			/** @description Current price of market moving asset */
			price: number
		}
		/**
		 * ExchangesResponse
		 * @description Returns an object representing the exchanges we support. The keys are the short form codes you will see in our responses and the values are their respective full names.
		 */
		ExchangesResponse: {
			[key: string]: string
		}
	}
	responses: never
	parameters: {
		/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
		"crypto-exchanges": string
		/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
		"crypto-exchange": "ERSX" | "CBSE" | "FTXU"
		/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
		"crypto-symbols": string
		/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
		"crypto-symbol": string
		/** @description Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour. */
		timeframe: string
		/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
		page_token: string
		/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
		start: string
		/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
		end: string
		/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
		limit: number
		/** @description The stock ticker symbol to query for. */
		"stock-symbol": string
		/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
		feed: "iex" | "sip" | "otc"
		/** @description specifies the corporate action adjustment(s) for bars data */
		adjustment: "raw" | "split" | "dividend" | "all"
		/** @description The comma-separated list of stock ticker symbols to query for. */
		"stock-symbols": string
	}
	requestBodies: never
	headers: never
	pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
	getBarsForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour. */
				timeframe: components["parameters"]["timeframe"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description specifies the corporate action adjustment(s) for bars data */
				adjustment?: components["parameters"]["adjustment"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiBarsResponse"]
				}
			}
		}
	}
	getLatestBarsForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiBarsResponse"]
				}
			}
		}
	}
	getBarsForStockSymbol: {
		parameters: {
			query: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour. */
				timeframe: components["parameters"]["timeframe"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
				/** @description specifies the corporate action adjustment(s) for bars data */
				adjustment?: components["parameters"]["adjustment"]
			}
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["BarsResponse"]
				}
			}
		}
	}
	getLatestBarForStockSymbol: {
		parameters: {
			query?: {
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path: {
				/** @description The stock ticker symbol to query for. */
				symbol: components["parameters"]["stock-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestBarResponse"]
				}
			}
		}
	}
	getTradesForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiTradesResponse"]
				}
			}
		}
	}
	getLatestTradesForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiTradesResponse"]
				}
			}
		}
	}
	getTradesForStockSymbol: {
		parameters: {
			query?: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path: {
				/**
				 * @description The symbol to query for
				 * @example AAPL
				 */
				symbol: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["TradesResponse"]
				}
			}
		}
	}
	getLatestTradeForStockSymbol: {
		parameters: {
			query?: {
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path: {
				/**
				 * @description The symbol to query for
				 * @example AAPL
				 */
				symbol: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestTradeResponse"]
				}
			}
		}
	}
	getQuotesForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response
			 *      */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiQuotesReponse"]
				}
			}
		}
	}
	getLatestQuotesForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiQuotesResponse"]
				}
			}
		}
	}
	getQuotesForStockSymbol: {
		parameters: {
			query?: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path: {
				/**
				 * @description The symbol to query for
				 * @example AAPL
				 */
				symbol: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["QuotesResponse"]
				}
			}
		}
	}
	getLatestQuoteForStockSymbol: {
		parameters: {
			query?: {
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path: {
				/**
				 * @description The symbol to query for
				 * @example AAPL
				 */
				symbol: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestQuoteResponse"]
				}
			}
		}
	}
	getSnapshotsForMultipleStockSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of stock ticker symbols to query for. */
				symbols: components["parameters"]["stock-symbols"]
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiSnapshotResponse"]
				}
			}
		}
	}
	getSnapshotForStockSymbol: {
		parameters: {
			query?: {
				/** @description Which feed to pull market data from. This is either `iex`, `otc`, or `sip`. `sip` and `otc` are only available to those with a subscription */
				feed?: components["parameters"]["feed"]
			}
			header?: never
			path: {
				/**
				 * @description The symbol to query for
				 * @example AAPL
				 */
				symbol: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["Snapshot"]
				}
			}
		}
	}
	getTradesForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiTradesResponse"]
				}
			}
		}
	}
	getLatestTradesForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiTradesResponse"]
				}
			}
		}
	}
	getTradesForCryptoSymbol: {
		parameters: {
			query?: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["TradesResponse"]
				}
			}
		}
	}
	getLatestTradesForCryptoSymbol: {
		parameters: {
			query: {
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestTradeResponse"]
				}
			}
		}
	}
	getBarsForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour. */
				timeframe: components["parameters"]["timeframe"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiBarsResponse"]
				}
			}
		}
	}
	getLatestBarsForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiBarsResponse"]
				}
			}
		}
	}
	getBarsForCryptoSymbol: {
		parameters: {
			query: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description Timeframe for the aggregation. Values are customizeable, frequently used examples: 1Min, 15Min, 1Hour, 1Day. Limits: 1Min-59Min, 1Hour-23Hour. */
				timeframe: components["parameters"]["timeframe"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["BarsResponse"]
				}
			}
		}
	}
	getLatestBarsForCryptoSymbol: {
		parameters: {
			query: {
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestBarResponse"]
				}
			}
		}
	}
	getQuotesForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiQuotesReponse"]
				}
			}
		}
	}
	getLatestQuotesForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiQuotesResponse"]
				}
			}
		}
	}
	getQuotesForCryptoSymbol: {
		parameters: {
			query?: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["QuotesResponse"]
				}
			}
		}
	}
	getLatestQuoteForCryptoSymbol: {
		parameters: {
			query: {
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestQuoteResponse"]
				}
			}
		}
	}
	getSnapshotsForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MultiSnapshotResponse"]
					"application/xml": Record<string, never>
					"multipart/form-data": Record<string, never>
				}
			}
		}
	}
	getSnapshotForCryptoSymbol: {
		parameters: {
			query: {
				/** @description Which crypto exchange to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchange: components["parameters"]["crypto-exchange"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["Snapshot"]
					"application/xml": Record<string, never>
				}
			}
		}
	}
	getLatestXBBOForMultipleCryptoSymbols: {
		parameters: {
			query: {
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestMultiXBBOResponse"]
				}
			}
		}
	}
	getLatestXBBOForCryptoSymbol: {
		parameters: {
			query?: {
				/** @description A comma separated list of which crypto exchanges to pull the data from. Alpaca currently supports `ERSX`, `CBSE`, and `FTXU` */
				exchanges?: components["parameters"]["crypto-exchanges"]
			}
			header?: never
			path: {
				/** @description The crypto symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				symbol: components["parameters"]["crypto-symbol"]
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["LatestXBBOResponse"]
				}
			}
		}
	}
	getCryptoMetaSpreads: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["CryptoSpreadsResponse"]
				}
			}
		}
	}
	getNews: {
		parameters: {
			query: {
				/** @description Filter data equal to or after this time in RFC-3339 format. Fractions of a second are not accepted. */
				start?: components["parameters"]["start"]
				/** @description Filter data equal to or before this time in RFC-3339 format. Fractions of a second are not accepted. */
				end?: components["parameters"]["end"]
				/** @description The comma-separated list of crypto symbols to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD,ETHUSD" would get both BTC and ETH */
				symbols: components["parameters"]["crypto-symbols"]
				/** @description Number of data points to return. Must be in range 1-10000, defaults to 1000. */
				limit?: components["parameters"]["limit"]
				/**
				 * @description Sort articles by updated date. Options: DESC, ASC
				 * @example DESC
				 */
				sort?: "DESC" | "ASC"
				/** @description Boolean indicator to include content for news articles (if available) */
				include_content?: boolean
				/** @description Boolean indicator to exclude news articles that do not contain content  */
				exclude_contentless?: boolean
				/** @description Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. */
				page_token?: components["parameters"]["page_token"]
			}
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Successful response */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["GetNewsResponse"]
				}
			}
		}
	}
	getTopMoversByMarketType: {
		parameters: {
			query?: {
				/** @description Number of top market movers to fetch (gainers and losers). Will return number top for each. By default 10 gainers and 10 losers. */
				top?: number
			}
			header?: never
			path: {
				/** @description Screen specific market (stocks or crypto) */
				market_type: "stocks" | "crypto"
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["MarketMoversResponse"]
				}
			}
		}
	}
	getLogoForSymbol: {
		parameters: {
			query?: {
				/** @description If true then the api will generate a placeholder image if no logo was found. Defaults to true */
				placeholder?: boolean
			}
			header?: never
			path: {
				/** @description The crypto or stock symbol to query for. Note, currently all crypto symbols must be appended with "USD", ie "BTCUSD" would be how you query for BTC. */
				crypto_or_stock_symbol: string
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description Returns the requested logo as an image. */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"image/*": string
				}
			}
			/** @description No Logo was found for this symbol. This code will only be returned if you set `placeholder` to false. Otherwise we will generate a placeholder image for this symbol */
			404: {
				headers: {
					[name: string]: unknown
				}
				content?: never
			}
		}
	}
	getExchanges: {
		parameters: {
			query?: never
			header?: never
			path?: never
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": components["schemas"]["ExchangesResponse"]
				}
			}
		}
	}
	getConditions: {
		parameters: {
			query: {
				/** @description What kind of conditions to retrieve, "A" and "B" return CTS, where "C" will give you UTP  */
				tape: "A" | "B" | "C"
			}
			header?: never
			path: {
				/** @description either "trade" or "quote" */
				type: "trade" | "quote"
			}
			cookie?: never
		}
		requestBody?: never
		responses: {
			/** @description OK
			 *
			 *     Response is a JSON object mapping a condition to a plain text description */
			200: {
				headers: {
					[name: string]: unknown
				}
				content: {
					"application/json": {
						[key: string]: unknown
					}
				}
			}
		}
	}
}
